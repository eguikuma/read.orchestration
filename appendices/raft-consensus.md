<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# appendix：Raft 合意アルゴリズム

## はじめに

[02-architecture](../02-architecture.md) では、etcd がクラスタのすべての状態を保存する<strong>分散キーバリューストア</strong>であり、<strong>唯一の情報源（Single Source of Truth）</strong>として機能することを学びました

また、etcd が複数のインスタンスで動作し、データの一貫性を保つために <strong>Raft</strong> と呼ばれる合意アルゴリズムを使っていることにも触れました

そこでは「etcd は複数インスタンスで動作し、1 つが壊れてもデータが失われない」という点を理解すれば十分としていました

この付録では、その先に踏み込みます

Raft がどのようにして複数のインスタンス間でデータの一貫性を保っているのか、その仕組みを見ていきます

---

## このページで学ぶこと

- <strong>合意の必要性</strong>
  - 複数のインスタンスが同じデータを持つために、なぜ合意が必要なのか
- <strong>Raft の基本概念</strong>
  - リーダー、フォロワー、候補者の 3 つの役割と任期の仕組み
- <strong>リーダー選出</strong>
  - リーダーがいなくなったとき、どのようにして新しいリーダーが選ばれるか
- <strong>ログの複製</strong>
  - クライアントからの書き込みが、どのようにして全インスタンスに反映されるか
- <strong>安全性の保証</strong>
  - コミットされたデータがなぜ失われないのか
- <strong>etcd における Raft</strong>
  - Raft の仕組みが etcd でどのように使われているか

---

## 目次

1. [なぜ合意が必要か](#なぜ合意が必要か)
2. [Raft の基本概念](#raft-の基本概念)
3. [リーダー選出](#リーダー選出)
4. [ログの複製](#ログの複製)
5. [安全性の保証](#安全性の保証)
6. [etcd における Raft](#etcd-における-raft)
7. [用語集](#用語集)
8. [参考資料](#参考資料)

---

## なぜ合意が必要か

[02-architecture](../02-architecture.md) で学んだように、etcd はクラスタの全状態を保存する唯一の情報源です

もし etcd が 1 つのインスタンスだけで動いていたら、そのインスタンスが停止した瞬間にクラスタの全状態が失われます

これを防ぐために、etcd は複数のインスタンスで同じデータを保持します

しかし、複数のインスタンスが同じデータを持つことは、簡単ではありません

### データの不一致が起きる理由

ネットワークは信頼できません

インスタンス間のメッセージは、途中で失われることがあります

メッセージが遅延して、送信時とは異なる順序で届くこともあります

同じメッセージが重複して届くこともあります

このような状況で、3 つの etcd インスタンスがあるとしましょう

クライアントが「キー A の値を 1 に設定する」というリクエストを送り、次に「キー A の値を 2 に設定する」というリクエストを送ったとします

もしインスタンスごとにリクエストの到着順序が異なれば、あるインスタンスではキー A の値が 1 に、別のインスタンスでは 2 になってしまいます

これが<strong>不一致な状態</strong>です

### 不一致がもたらす問題

etcd の不一致は、クラスタ全体に影響を及ぼします

たとえば、Controller Manager が「Web サーバーの Pod を 3 つ維持する」という情報を読み取る際に、あるインスタンスからは「3 つ」、別のインスタンスからは古い「2 つ」という値が返ってくる可能性があります

これでは、唯一の情報源としての役割を果たせません

### 合意が解決すること

合意（Consensus）とは、複数のインスタンスが<strong>同じ操作を、同じ順序で実行することに同意する</strong>仕組みです

メッセージの喪失や遅延が起きる不完全なネットワーク環境でも、すべてのインスタンスが同じデータの状態に到達できることを保証します

Raft は、この合意を実現するアルゴリズムの 1 つです

---

## Raft の基本概念

Raft は、合意アルゴリズムを<strong>理解しやすくする</strong>ことを設計目標として作られました

論文のタイトル「In Search of an Understandable Consensus Algorithm」（理解しやすい合意アルゴリズムを求めて）が、この設計思想を端的に表しています

Raft では、合意の問題を 2 つの独立した部分問題に分解しています

1 つは<strong>リーダー選出</strong>（誰がリーダーになるか）、もう 1 つは<strong>ログの複製</strong>（データをどう全体に行き渡らせるか）です

この分解が、Raft を理解しやすくしている鍵です

### 3 つの役割

Raft に参加するインスタンス（ノード）は、常に以下の 3 つの役割のいずれかを持ちます

| 役割                                    | 説明                                                                                                     |
| --------------------------------------- | -------------------------------------------------------------------------------------------------------- |
| <strong>リーダー（Leader）</strong>     | クライアントからのリクエストを受け付け、ログエントリを他のノードに複製し、定期的にハートビートを送信する |
| <strong>フォロワー（Follower）</strong> | リーダーからのリクエストに応答し、クライアントからのリクエストはリーダーに転送する                       |
| <strong>候補者（Candidate）</strong>    | リーダー選出の際に、他のノードに投票を依頼する                                                           |

通常の動作では、1 つのリーダーと残り全員のフォロワーで構成されます

候補者は、リーダーの選出が必要なときにだけ一時的に出現します

### 任期（Term）

Raft は<strong>任期（Term）</strong>という概念で時間を区切ります

任期は 1 から始まる整数で、選挙が行われるたびに 1 つ増えます

各任期には、<strong>最大で 1 人のリーダー</strong>しか存在しません

任期はいわば「論理的な時計」です

ノード間で物理的な時刻を同期する必要はなく、任期の番号を比較するだけで「どちらの情報が新しいか」を判断できます

あるノードが自分よりも大きな任期番号を持つメッセージを受け取った場合、そのノードは自分の情報が古いことを認識し、フォロワーに戻ります

---

## リーダー選出

Raft では、すべてのクライアントリクエストをリーダーが処理します

そのため、リーダーが存在しない状態ではクラスタは書き込みを受け付けられません

リーダーが停止した場合に、速やかに新しいリーダーを選ぶ仕組みが<strong>リーダー選出</strong>です

### 選出の流れ

<strong>1. ハートビートによる生存確認</strong>

リーダーは定期的に<strong>ハートビート</strong>（心拍）と呼ばれるメッセージをすべてのフォロワーに送信します

フォロワーはハートビートを受け取ることで、リーダーが正常に動作していることを確認します

<strong>2. 選挙タイムアウト</strong>

フォロワーには<strong>選挙タイムアウト</strong>と呼ばれる待ち時間が設定されています

この時間内にリーダーからハートビートが届かない場合、フォロワーは「リーダーが停止した」と判断します

<strong>3. 候補者への移行</strong>

リーダーの停止を検知したフォロワーは、自分の役割を<strong>候補者</strong>に変更します

候補者は以下の 3 つの処理を行います

- 任期を 1 つ増やす
- 自分自身に投票する
- 他のすべてのノードに投票リクエスト（RequestVote RPC）を送信する

<strong>4. 投票と当選</strong>

投票リクエストを受け取ったノードは、1 つの任期につき 1 票だけ投票できます

候補者が<strong>過半数（クォーラム）</strong>の票を獲得すると、新しいリーダーとして選出されます

たとえば、5 ノードのクラスタでは 3 票が必要です

<strong>5. 新リーダーの始動</strong>

選出されたリーダーは、直ちにすべてのノードにハートビートを送信し、自分がリーダーであることを宣言します

これにより、他の候補者はフォロワーに戻り、選挙が終了します

### 選挙タイムアウトのランダム化

もし全てのフォロワーが同じタイミングで候補者になると、複数の候補者が同時に投票を求め、票が分散してしまいます

この状態を<strong>スプリットボート（票の分裂）</strong>と呼びます

スプリットボートが起きると、どの候補者も過半数の票を獲得できず、選挙が失敗します

Raft はこの問題を、<strong>選挙タイムアウトをランダム化する</strong>ことで解決しています

各フォロワーの選挙タイムアウトは、一定の範囲内でランダムに設定されます

これにより、あるフォロワーが他より先にタイムアウトし、先に候補者になります

先に候補者になったノードは、他のノードがまだフォロワーである間に投票を集められるため、スプリットボートの発生を大幅に減らせます

この単純なランダム化が、Raft の設計における重要な工夫の 1 つです

複雑なプロトコルを必要とせず、確率的にほぼ確実に 1 人のリーダーが選出されます

---

## ログの複製

リーダーが選出されると、クラスタはクライアントからのリクエストを処理できるようになります

Raft では、すべてのリクエストを<strong>ログエントリ</strong>として記録し、全ノードに複製することでデータの一貫性を保ちます

### 複製の流れ

ログの複製は、以下の手順で進みます

<strong>手順 1：クライアントがリーダーにリクエストを送信する</strong>

たとえば、「キー A の値を 1 に設定する」というリクエストがリーダーに届きます

<strong>手順 2：リーダーがログエントリを作成する</strong>

リーダーはリクエストの内容を新しいログエントリとして自分のログに追加します

ログエントリには、操作の内容と任期番号が記録されます

<strong>手順 3：リーダーが全フォロワーにログエントリを送信する</strong>

リーダーは <strong>AppendEntries RPC</strong> というメッセージを使い、新しいログエントリをすべてのフォロワーに送信します

<strong>手順 4：フォロワーがログエントリを記録し、応答する</strong>

各フォロワーはログエントリを自分のログに追加し、リーダーに成功の応答を返します

<strong>手順 5：リーダーが過半数の応答を確認し、コミットする</strong>

リーダーは<strong>過半数のノード</strong>（自分を含む）がログエントリを記録したことを確認すると、そのエントリを<strong>コミット</strong>済みとして扱います

コミットとは、「このエントリは確定した」という状態を意味します

<strong>手順 6：コミットされたエントリをステートマシンに適用する</strong>

リーダーはコミットされたエントリを自分のステートマシン（キーバリューストア）に適用し、結果をクライアントに返します

次のハートビートまたは AppendEntries RPC で、フォロワーにもコミット位置が通知されます

フォロワーは通知を受けて、自分のステートマシンにもエントリを適用します

### なぜ過半数なのか

過半数を条件とする理由は、<strong>どの 2 つの過半数にも、必ず少なくとも 1 つの共通メンバーが存在する</strong>からです

たとえば 5 ノードのクラスタでは、過半数は 3 ノードです

ある操作をコミットした 3 ノードと、次の選挙で投票する 3 ノードの間には、必ず 1 ノード以上の重なりがあります

この重なりにより、コミットされた情報は次のリーダーにも引き継がれます

---

## 安全性の保証

Raft が保証する重要な性質に、<strong>Leader Completeness Property</strong>（リーダー完全性）があります

これは「一度コミットされたログエントリは、以降のすべてのリーダーのログに含まれる」という性質です

### なぜこの性質が成り立つか

候補者がリーダーに選出されるためには、過半数のノードから投票を得る必要があります

投票する側のノードは、候補者のログが自分のログよりも古い場合、投票を拒否します

コミットされたエントリは過半数のノードに存在しています

候補者が投票を得るためには過半数のノードの賛成が必要です

この 2 つの過半数には必ず重なりがあるため、コミット済みエントリを持つノードが少なくとも 1 つは投票者に含まれます

そのノードは、コミット済みエントリを持たない候補者への投票を拒否します

結果として、コミット済みエントリを持たない候補者はリーダーになれません

この仕組みにより、リーダーが交代しても、コミットされたデータが失われることはありません

---

## etcd における Raft

[02-architecture](../02-architecture.md) で学んだ etcd は、内部で Raft を使用してデータを複数のインスタンス間で複製しています

ここでは、Raft の仕組みが etcd でどのように活用されているかを見ていきます

### クォーラムとインスタンス数

etcd クラスタでは、書き込みが成功するために<strong>過半数（クォーラム）</strong>のインスタンスの同意が必要です

インスタンス数とクォーラムの関係は以下の通りです

| インスタンス数 | クォーラム | 許容される障害数 |
| -------------- | ---------- | ---------------- |
| 3              | 2          | 1                |
| 5              | 3          | 2                |
| 7              | 4          | 3                |

### なぜ奇数が推奨されるか

etcd のインスタンス数には奇数が推奨されます

その理由は、偶数にしても障害耐性が向上しないためです

たとえば、4 インスタンスのクォーラムは 3 です

これは、4 インスタンスのうち 1 つが停止するとクォーラムが 3 対 3 で満たせなくなるため、許容される障害数は 1 です

3 インスタンスの場合も、許容される障害数は同じく 1 です

つまり、4 インスタンスは 3 インスタンスと比べてインスタンスが 1 つ多いにもかかわらず、障害耐性は同じです

追加のインスタンスは障害耐性に貢献せず、書き込み時に同意が必要なノード数だけが増えます

### 書き込みのコスト

Raft を使う以上、すべての書き込みは過半数のインスタンスが応答するまで完了しません

これは、単一インスタンスに比べて書き込みに時間がかかることを意味します

インスタンス数が増えるほど、同意に必要なノード数も増えるため、書き込みの遅延（レイテンシ）は大きくなる傾向があります

これは<strong>障害耐性と書き込み性能のトレードオフ</strong>です

etcd のインスタンス数を 3 や 5 に設定するのが一般的なのは、このトレードオフのバランスを取った結果です

### Single Source of Truth の実現

[02-architecture](../02-architecture.md) では、etcd がクラスタの<strong>唯一の情報源（Single Source of Truth）</strong>であると学びました

Raft はこの「唯一の情報源」を技術的に支える仕組みです

Raft によって、どの etcd インスタンスに問い合わせても同じデータが返ることが保証されます

1 つのインスタンスが停止しても、残りのインスタンスが過半数を維持していればデータは失われず、クラスタの状態は正しく保たれます

これが、[02-architecture](../02-architecture.md) で述べた「etcd は複数インスタンスで動作し、1 つが壊れてもデータが失われない」の背後にある仕組みです

---

## 用語集

| 用語                                 | 説明                                                                                                          |
| ------------------------------------ | ------------------------------------------------------------------------------------------------------------- |
| Raft                                 | 複数のノード間でデータの一貫性を保つための合意アルゴリズムであり、理解しやすさを設計目標として作られた        |
| 合意（Consensus）                    | 複数のノードが同じ操作を同じ順序で実行することに同意する仕組み                                                |
| リーダー（Leader）                   | クライアントからのリクエストを受け付け、ログエントリを他のノードに複製する役割                                |
| フォロワー（Follower）               | リーダーからのリクエストに応答し、クライアントからのリクエストをリーダーに転送する役割                        |
| 候補者（Candidate）                  | リーダー選出の際に、他のノードに投票を依頼する一時的な役割                                                    |
| 任期（Term）                         | Raft における論理的な時計であり、選挙が行われるたびに 1 つ増える整数値                                        |
| ログ複製（Log Replication）          | リーダーがクライアントのリクエストをログエントリとして全ノードに複製する仕組み                                |
| コミット（Commit）                   | 過半数のノードがログエントリを記録し、そのエントリが確定した状態                                              |
| クォーラム（Quorum）                 | 操作を確定するために必要な最小限のノード数であり、過半数で定義される                                          |
| 選挙タイムアウト（Election Timeout） | フォロワーがリーダーからのハートビートを待つ制限時間であり、タイムアウトすると選挙を開始する                  |
| ハートビート（Heartbeat）            | リーダーがフォロワーに定期的に送信する生存確認のメッセージ                                                    |
| AppendEntries RPC                    | リーダーがフォロワーにログエントリを送信するために使うリモートプロシージャコール                              |
| RequestVote RPC                      | 候補者が他のノードに投票を依頼するために使うリモートプロシージャコール                                        |
| スプリットボート（Split Vote）       | 複数の候補者が同時に選挙を行い、票が分散してどの候補者も過半数を獲得できない状態                              |
| Leader Completeness Property         | 一度コミットされたログエントリが、以降のすべてのリーダーのログに含まれることを保証する性質                    |
| ステートマシン（State Machine）      | コミットされたログエントリを適用してデータを保持する仕組みであり、etcd ではキーバリューストアがこれに該当する |

---

## 参考資料

このページの内容は、以下のソースに基づいています

<strong>Raft 合意アルゴリズム</strong>

- "In Search of an Understandable Consensus Algorithm" (Ongaro & Ousterhout, 2014)
  - https://raft.github.io/raft.pdf
  - Raft 合意アルゴリズムの原論文であり、リーダー選出、ログ複製、安全性の保証について詳述している

<strong>etcd</strong>

- [etcd Documentation](https://etcd.io/docs/)
  - etcd の公式ドキュメントであり、Raft を基盤とした分散キーバリューストアの仕様と設計を扱う

<strong>教育用リソース</strong>

- [Raft Visualization](https://raft.github.io/)
  - Raft のリーダー選出とログ複製の動作をインタラクティブに確認できる教育用ツール
