<div align="right">
<img src="https://img.shields.io/badge/AI-ASSISTED_STUDY-3b82f6?style=for-the-badge&labelColor=1e293b&logo=bookstack&logoColor=white" alt="AI Assisted Study" />
</div>

# appendix：CNI（Container Network Interface）

## はじめに

[04-service-discovery](../04-service-discovery.md) では、Kubernetes のネットワークモデルを学びました

すべての Pod が固有の IP アドレスを持ち、NAT なしで他のすべての Pod と通信できるという要件を確認しました

Service が安定したアクセス先を提供し、DNS が名前解決を行い、kube-proxy がトラフィックを転送する仕組みを見てきました

また、用語集では CNI（Container Network Interface）が Pod への IP アドレス割り当てとネットワーク接続を担当する標準インターフェースであると紹介しました

しかし、<strong>どのようにして</strong> Pod に IP アドレスが割り当てられ、異なるノード上の Pod 同士が通信できるようになるのかは説明していませんでした

前のシリーズでコンテナの仕組みを学んだ方は、bridge ネットワークと veth ペアによる単一ホスト上のコンテナネットワーキングを思い出すかもしれません

bridge は 1 台のマシン内のネットワークスイッチであり、veth ペアはコンテナをその bridge に接続する仮想ケーブルでした

しかし、bridge は 1 台のマシンに閉じた仕組みです

異なるマシン上のコンテナ同士が bridge を通じて直接通信することはできません

この appendix では、単一ホストのコンテナネットワークから、複数ノードにまたがるクラスタネットワークへの橋渡しとして、<strong>CNI の仕組み</strong>を学びます

---

## このページで学ぶこと

- <strong>CNI の必要性</strong>
  - 単一ホストの bridge ネットワークではなぜクラスタネットワークを実現できないか
- <strong>CNI の役割</strong>
  - コンテナランタイムとネットワークプラグインを分離する仕様
- <strong>CNI プラグインの責務</strong>
  - IP アドレスの割り当て、ネットワークインターフェースの設定、ルーティングの設定
- <strong>CNI の動作フロー</strong>
  - Pod 作成時にネットワークが構成されるまでの流れ
- <strong>オーバーレイネットワークとルーティング</strong>
  - ノード間の Pod 通信を実現する 2 つのアプローチ

---

## 目次

1. [なぜ CNI が必要か](#なぜ-cni-が必要か)
2. [CNI とは](#cni-とは)
3. [CNI プラグインの役割](#cni-プラグインの役割)
4. [CNI の動作フロー](#cni-の動作フロー)
5. [オーバーレイネットワークとルーティング](#オーバーレイネットワークとルーティング)
6. [代表的な CNI プラグイン](#代表的な-cni-プラグイン)
7. [用語集](#用語集)
8. [参考資料](#参考資料)

---

## なぜ CNI が必要か

### 単一ホストのコンテナネットワーク

前のシリーズでコンテナネットワークを学んだ方は、以下の仕組みを思い出すかもしれません

<strong>bridge</strong>は、1 台のマシン内で動作する仮想的なネットワークスイッチです

<strong>veth ペア</strong>は、コンテナと bridge をつなぐ仮想的なネットワークケーブルです

コンテナが作成されると、veth ペアの一方がコンテナ内に、もう一方が bridge に接続されます

これにより、同じマシン上のコンテナ同士は bridge を経由して通信できます

```
┌───────────────────────────────────────────────┐
│                ホストマシン                     │
│                                               │
│   ┌──────────┐   ┌──────────┐                 │
│   │コンテナ A │   │コンテナ B │                 │
│   │ veth     │   │ veth     │                 │
│   └────┬─────┘   └────┬─────┘                 │
│        │              │                       │
│   ┌────┴──────────────┴────┐                   │
│   │        bridge          │                   │
│   └────────────────────────┘                   │
│                                               │
└───────────────────────────────────────────────┘
```

この仕組みは、1 台のマシン内では正しく機能します

### bridge の限界

しかし、Kubernetes のクラスタは複数のノード（マシン）で構成されます

bridge は 1 台のマシン内に閉じた仕組みであるため、<strong>異なるノード上のコンテナ同士は bridge を通じて直接通信できません</strong>

```
┌──────────────────┐       ┌──────────────────┐
│     ノード 1      │       │     ノード 2      │
│                  │       │                  │
│  ┌────────────┐  │       │  ┌────────────┐  │
│  │  Pod A     │  │       │  │  Pod B     │  │
│  └─────┬──────┘  │       │  └─────┬──────┘  │
│        │         │       │        │         │
│  ┌─────┴──────┐  │       │  ┌─────┴──────┐  │
│  │  bridge    │  │  ???  │  │  bridge    │  │
│  └────────────┘  │       │  └────────────┘  │
│                  │       │                  │
└──────────────────┘       └──────────────────┘
```

ノード 1 の bridge とノード 2 の bridge は互いに独立しています

Pod A から Pod B に通信しようとしても、パケットはノード 1 の bridge から出ることができません

### Kubernetes のネットワーク要件

[04-service-discovery](../04-service-discovery.md) で確認した通り、Kubernetes のネットワークモデルには以下の要件があります

- すべての Pod が固有の IP アドレスを持つ
- すべての Pod は、NAT なしで他のすべての Pod と通信できる
- Pod が自分の IP アドレスとして認識する IP は、他の Pod から見ても同じ IP である

これらの要件を満たすには、単一ホストの bridge ネットワークだけでは不十分です

### 解決すべき課題

bridge の限界と Kubernetes の要件の間には、解決すべき課題があります

| 課題                               | 説明                                                      |
| ---------------------------------- | --------------------------------------------------------- |
| IP アドレスの割り当て              | クラスタ全体で重複しない IP アドレスを各 Pod に割り当てる |
| ネットワークインターフェースの設定 | Pod 内に仮想ネットワークインターフェースを作成する        |
| ノード間ルーティングの設定         | 異なるノード上の Pod 間でパケットが届くようにする         |

これらの課題を解決するのが、<strong>CNI プラグイン</strong>です

---

## CNI とは

### 仕様としての CNI

<strong>CNI（Container Network Interface）</strong>は、コンテナランタイムがネットワークプラグインと連携するための<strong>仕様（specification）</strong>です

CNI 自体はソフトウェアでも実装でもありません

「コンテナのネットワークをどのように構成するか」について、コンテナランタイムとネットワークプラグインの間の<strong>取り決め</strong>を定義したものです

### CNI が定義する操作

CNI 仕様では、以下の操作が定義されています

| 操作    | 説明                                          |
| ------- | --------------------------------------------- |
| ADD     | コンテナをネットワークに接続する              |
| DEL     | コンテナをネットワークから切断する            |
| CHECK   | コンテナのネットワーク接続が正常かを確認する  |
| VERSION | プラグインがサポートする CNI バージョンを返す |

コンテナランタイムは、これらの操作を CNI プラグインに対して呼び出します

CNI プラグインは実行可能ファイル（バイナリ）であり、コンテナランタイムから呼び出されると、指定された操作を実行して結果を返します

### CRI との類似性

[02-architecture](../02-architecture.md) で、kubelet がコンテナランタイムと連携するために CRI（Container Runtime Interface）を使うことを学びました

CRI は「コンテナの管理方法」をランタイムの実装から分離する仕組みでした

kubelet は CRI に準拠した命令を出すだけで、その先のコンテナランタイムが何であるかを気にする必要がありません

CNI もこれと同じ考え方です

CNI は「ネットワークの構成方法」をプラグインの実装から分離します

コンテナランタイムは CNI の仕様に従って操作を呼び出すだけで、その先のネットワークプラグインが何であるかを気にする必要がありません

| インターフェース | 分離するもの           | 呼び出す側         | 呼び出される側                      |
| ---------------- | ---------------------- | ------------------ | ----------------------------------- |
| CRI              | コンテナ管理の実装     | kubelet            | コンテナランタイム（containerd 等） |
| CNI              | ネットワーク構成の実装 | コンテナランタイム | ネットワークプラグイン              |

この分離により、ネットワークプラグインを変更しても、Kubernetes やコンテナランタイムのコードを変更する必要がありません

---

## CNI プラグインの役割

### 3 つの責務

CNI プラグインは、Pod のネットワークを構成するために以下の 3 つの責務を担います

| 責務                               | 説明                                                                 |
| ---------------------------------- | -------------------------------------------------------------------- |
| IP アドレスの割り当て              | Pod に固有の IP アドレスを割り当てる                                 |
| ネットワークインターフェースの設定 | Pod 内に仮想ネットワークインターフェース（veth ペア等）を作成する    |
| ルーティングの設定                 | Pod 間のトラフィックが正しく届くようにルーティングテーブルを設定する |

これらの責務が、先ほど挙げた「解決すべき課題」に対応しています

### IPAM（IP アドレス管理）

IP アドレスの割り当ては、<strong>IPAM（IP Address Management）プラグイン</strong>と呼ばれるサブプラグインが担当します

IPAM プラグインは、メインの CNI プラグインから呼び出されるもう 1 つのプラグインです

IPAM プラグインの責務は、クラスタ全体で重複しない IP アドレスを各 Pod に割り当てることです

メインの CNI プラグインがネットワークインターフェースの作成とルーティングの設定を行い、IPAM プラグインが IP アドレスの割り当てを行うという分担になっています

### JSON による設定

CNI プラグインは、コンテナランタイムから JSON 形式の設定を受け取ります

この設定には、どのネットワークに接続するか、どの IPAM プラグインを使うかなどの情報が含まれています

CNI プラグインは設定に従ってネットワークを構成し、結果（割り当てた IP アドレスなど）を JSON 形式で返します

---

## CNI の動作フロー

### Pod 作成時のネットワーク構成

Pod が作成されるとき、ネットワークは以下の流れで構成されます

1. kubelet が Pod の作成を指示する
2. コンテナランタイム（containerd）が CRI 経由で呼び出される
3. ランタイムがネットワーク namespace を作成する
4. ランタイムが CNI プラグインを実行する
5. CNI プラグインが veth ペアを作成し、Pod 側に接続する
6. IPAM プラグインが IP アドレスを割り当てる
7. ルーティングが設定される
8. Pod がネットワーク通信可能になる

```
kubelet
  │
  │ CRI
  ▼
containerd
  │
  │ 1. ネットワーク namespace を作成
  │ 2. CNI プラグインを実行
  │
  ▼
CNI プラグイン
  │
  │ 3. veth ペアを作成
  │ 4. IPAM プラグインを呼び出し
  │ 5. ルーティングを設定
  │
  ▼
Pod がネットワーク通信可能
```

### 各ステップの詳細

<strong>ネットワーク namespace の作成</strong>

コンテナランタイムは、Pod 用のネットワーク namespace を作成します

ネットワーク namespace は、Pod に独立したネットワーク空間を提供する仕組みです

Pod は自分専用のネットワークインターフェース、IP アドレス、ルーティングテーブルを持ちます

前のシリーズでカーネル空間を学んだ方は、Linux の namespace によるプロセスの隔離を思い出すかもしれません

ネットワーク namespace はその一種であり、ネットワーク資源を分離します

<strong>CNI プラグインの実行</strong>

コンテナランタイムは、CNI の ADD 操作で CNI プラグインを実行します

このとき、Pod のネットワーク namespace の情報と、JSON 形式の設定がプラグインに渡されます

<strong>veth ペアの作成と接続</strong>

CNI プラグインは、veth ペアを作成します

veth ペアの一方を Pod のネットワーク namespace 内に配置し、もう一方をホスト側のネットワークに接続します

これは、前のシリーズで学んだコンテナネットワークの veth ペアと同じ仕組みです

<strong>IPAM プラグインによる IP アドレスの割り当て</strong>

CNI プラグインは IPAM プラグインを呼び出し、Pod に割り当てる IP アドレスを取得します

取得した IP アドレスが Pod のネットワークインターフェースに設定されます

<strong>ルーティングの設定</strong>

CNI プラグインは、Pod 宛てのトラフィックが正しく届くようにルーティングテーブルを設定します

ノード間の Pod 通信を実現するために、適切なルーティングルールが追加されます

### アーキテクチャ全体における位置づけ

この動作フローは、[02-architecture](../02-architecture.md) で学んだ「kubelet が Pod を起動する」流れと、[04-service-discovery](../04-service-discovery.md) で学んだ「Pod が IP アドレスを持つ」状態をつなぐ、間の部分です

[02-architecture](../02-architecture.md) では、kubelet が CRI を通じてコンテナランタイムにコンテナの起動を依頼する流れを学びました

その流れの中で、コンテナランタイムが CNI プラグインを呼び出してネットワークを構成する部分が、この appendix で学んだ内容にあたります

---

## オーバーレイネットワークとルーティング

### ノード間通信の課題

CNI プラグインは、同じノード内の Pod 同士のネットワーク構成だけでなく、<strong>異なるノード上の Pod 同士の通信</strong>も実現する必要があります

ノード 1 上の Pod A（IP: 10.244.1.5）からノード 2 上の Pod B（IP: 10.244.2.8）にパケットを送るとき、そのパケットはどうやってノード 2 に届くのでしょうか

この課題に対して、CNI プラグインは大きく 2 つのアプローチを採用しています

### オーバーレイネットワーク

<strong>オーバーレイネットワーク</strong>は、既存のネットワーク（物理ネットワーク）の上に、仮想的なネットワークを重ねる方式です

オーバーレイネットワークでは、Pod 間のパケットを別のパケットで包み込んで（カプセル化して）転送します

代表的なカプセル化方式に VXLAN（Virtual Extensible LAN）があります

<strong>カプセル化の仕組み</strong>

Pod A が Pod B にパケットを送ると、送信元ノードで以下の処理が行われます

1. Pod A が送信したパケット（送信元: Pod A の IP、宛先: Pod B の IP）を取り出す
2. このパケット全体を、新しいパケットのデータ部分に格納する（カプセル化）
3. 新しいパケットの送信元にノード 1 の IP、宛先にノード 2 の IP を設定する
4. 新しいパケットをノード 2 に送信する

宛先ノードでは逆の処理（デカプセル化）が行われます

1. 受信したパケットから外側のヘッダを取り除く
2. 内側の元のパケット（送信元: Pod A の IP、宛先: Pod B の IP）を取り出す
3. 取り出したパケットを Pod B に転送する

```
Pod A（10.244.1.5）──→ Pod B（10.244.2.8）に送信

ノード 1 でカプセル化：
┌──────────────────────────────────────────────────┐
│ 外側ヘッダ                                       │
│ 送信元：ノード 1 の IP   宛先：ノード 2 の IP     │
│ ┌──────────────────────────────────────────────┐ │
│ │ 内側パケット（元のパケット）                  │ │
│ │ 送信元：10.244.1.5   宛先：10.244.2.8        │ │
│ └──────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────┘

ノード 2 でデカプセル化：
内側パケットを取り出し、Pod B に転送
```

<strong>オーバーレイネットワークの特徴</strong>

オーバーレイネットワークの利点は、<strong>物理ネットワークの構成に依存しない</strong>ことです

外側のパケットはノード間の通常の IP 通信であるため、物理ネットワークのルーターやスイッチに特別な設定は不要です

一方、カプセル化とデカプセル化の処理が追加されるため、わずかなオーバーヘッド（追加の処理負荷）が発生します

### ルーティング方式

<strong>ルーティング方式</strong>は、カプセル化を行わず、標準的な IP ルーティングで Pod 間の通信を実現する方式です

各ノードが「自分のノード上の Pod の IP 範囲はこれである」という情報をネットワーク全体に広報（アドバタイズ）します

この広報には BGP（Border Gateway Protocol）などのルーティングプロトコルが使われます

ネットワーク上のルーターは、この情報を学習し、Pod 宛てのパケットを正しいノードに転送できるようになります

<strong>ルーティング方式の仕組み</strong>

1. ノード 1 が「10.244.1.0/24 はノード 1 にある」と広報する
2. ノード 2 が「10.244.2.0/24 はノード 2 にある」と広報する
3. ルーターがこの情報を学習する
4. Pod A（10.244.1.5）から Pod B（10.244.2.8）へのパケットは、ルーターが宛先 IP に基づいてノード 2 に転送する

<strong>ルーティング方式の特徴</strong>

ルーティング方式の利点は、カプセル化のオーバーヘッドがないことです

パケットはそのまま転送されるため、性能面で有利です

一方、ネットワーク上のルーターが Pod の IP 範囲を理解し、ルーティングに参加できる必要があります

すべてのネットワーク環境でこの方式が使えるわけではありません

### 2 つのアプローチの比較

| アプローチ   | 転送の仕組み             | 利点                             | 必要な条件           |
| ------------ | ------------------------ | -------------------------------- | -------------------- |
| オーバーレイ | VXLAN 等によるカプセル化 | ネットワーク環境を問わず動作する | なし                 |
| ルーティング | BGP 等による経路広報     | カプセル化のオーバーヘッドがない | ルーターの対応が必要 |

どちらのアプローチも、CNI の仕様に準拠した CNI プラグインとして実装されています

Kubernetes から見れば、どちらのプラグインを使っても Pod は同じように IP アドレスを持ち、他の Pod と通信できます

---

## 代表的な CNI プラグイン

CNI の仕様に準拠したプラグインはいくつか存在します

ここでは、代表的なプラグインを簡単に紹介します

| プラグイン | アプローチ                            | 特徴                                                         |
| ---------- | ------------------------------------- | ------------------------------------------------------------ |
| Flannel    | オーバーレイ（VXLAN）                 | 設定がシンプルで導入しやすい                                 |
| Calico     | ルーティング（BGP）またはオーバーレイ | Network Policy によるトラフィック制御をサポートする          |
| Cilium     | eBPF ベース                           | カーネルレベルでのネットワーク処理と高度な可観測性を提供する |

すべてのプラグインは同じ CNI 仕様に準拠しているため、<strong>Kubernetes から見れば互換性があります</strong>

CNI プラグインを変更しても、Pod のネットワークモデル（固有の IP、NAT なしの通信）は同じように機能します

どの CNI プラグインを選択するかは、クラスタの運用要件に応じた判断であり、このリポジトリの範囲を超えます

この appendix の目的は、CNI という仕組みが Pod のネットワーク構成をどのように実現するかを理解することです

---

## 用語集

| 用語                                        | 説明                                                                                                             |
| ------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- |
| CNI（Container Network Interface）          | コンテナランタイムがネットワークプラグインと連携するための仕様。ネットワーク構成の実装をプラグインとして分離する |
| CNI プラグイン                              | CNI 仕様に準拠した実行可能ファイル。コンテナランタイムから呼び出され、Pod のネットワーク構成を行う               |
| IPAM（IP Address Management）               | IP アドレスの割り当てを担当する CNI のサブプラグイン。クラスタ全体で重複しない IP アドレスを各 Pod に割り当てる  |
| オーバーレイネットワーク（Overlay Network） | 既存のネットワークの上に仮想的なネットワークを重ねる方式。パケットをカプセル化して転送する                       |
| VXLAN（Virtual Extensible LAN）             | オーバーレイネットワークで使用される代表的なカプセル化プロトコル                                                 |
| BGP（Border Gateway Protocol）              | ルーティング方式で使用されるルーティングプロトコル。ネットワーク間の経路情報を交換する                           |
| veth ペア                                   | 仮想的なネットワークケーブル。一方をコンテナ（Pod）内に、もう一方をホスト側のネットワークに接続する              |

---

## 参考資料

このページの内容は、以下のソースに基づいています

<strong>CNI 仕様</strong>

- [CNI Specification](https://github.com/containernetworking/cni/blob/main/SPEC.md)
  - CNI の仕様を定義するリポジトリで、ADD / DEL / CHECK / VERSION の操作やプラグインのインターフェースが記載されている

<strong>Kubernetes ネットワーキング</strong>

- [Cluster Networking](https://kubernetes.io/docs/concepts/cluster-administration/networking/)
  - Kubernetes のネットワークモデル（Pod ごとの IP、NAT なしの通信要件）の公式ドキュメント

- [Network Plugins](https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/)
  - Kubernetes における CNI プラグインの使用方法の公式ドキュメント
